<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <meta name="description" content="A fast, client-side tool to rotate and delete pages in a PDF file directly in your browser. No uploads, 100% private."/>
    <title>PDF Page Editor - Rotate & Delete</title>

    <!-- FAVICON -->
    <link rel="icon" href="./assets/svg/logo.svg" type="image/svg+xml">

    <!-- 1) Preconnect for Google Fonts for faster connection -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />

    <!-- JS Libraries (pdf-lib, pdf.js, and JSZip) - Deferred for non-blocking load -->
    <script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js" defer></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.min.js" defer></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js" defer></script>

    <!-- 2) Non-blocking load for Google Fonts stylesheet -->
    <link rel="preload" href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" as="style" />
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" media="print" onload="this.media='all'" />

    <!-- 3) Non-blocking load for Tailwind CSS build -->
    <link rel="preload" href="./assets/style/style.css" as="style" />
    <link rel="stylesheet" href="./assets/style/style.css" media="print" onload="this.media='all'" />
    <link rel="stylesheet" href="./assets/style/style.css" />

    <!-- Main application scripts - Deferred -->
    <script src="./assets/js/header.js" defer></script>
    <script src="./assets/js/footer.js" defer></script>
    <script src="./assets/js/main.js" defer></script>
</head>

<body class="bg-slate-200 font-sans text-slate-800 flex min-h-screen flex-col transition-colors duration-300 dark:bg-slate-900 dark:text-slate-200">

<div id="header-placeholder"></div>

<main class="flex-grow w-full">
    <div class="p-4 sm:p-6 mt-16 mx-auto">
        <div class="mb-4">
          <div id="topad-1" aria-label="Top Ad 1"></div>
        </div>

        <div class="lg:grid lg:grid-cols-[side_bar] lg:gap-4">

            <div class="min-w-0 overflow-hidden">
                <section class="bg-white p-4 sm:p-6 lg:p-8 rounded-2xl border border-indigo-300 dark:bg-slate-800 dark:border-slate-700">
                    <div class="text-center mb-8">
                        <h1 class="text-3xl lg:text-4xl font-extrabold bg-gradient-to-r from-indigo-500 via-purple-500 to-pink-500 bg-clip-text text-transparent">PDF Page Editor</h1>
                        <p class="mt-2 max-w-2xl mx-auto text-lg text-slate-600 dark:text-slate-400">Securely delete, extract, and manage PDF pages—all in your browser.</p>
                    </div>

                    <!-- Step 1: Upload -->
                    <section id="upload-section">
                        <div id="upload-area" class="w-full max-w-2xl mx-auto">
                            <label for="file-input" class="block text-center p-8 border-2 border-dashed border-slate-400 dark:border-slate-500 rounded-lg cursor-pointer transition-colors hover:border-indigo-600 dark:hover:border-indigo-300 bg-slate-100 dark:bg-slate-900">
                                <div class="flex flex-col items-center justify-center space-y-4 pointer-events-none">
                                    <p class="text-lg font-medium text-slate-700 dark:text-slate-300">Drag & drop your PDF file here</p>
                                    <span class="text-slate-500 text-lg font-medium dark:text-slate-400">or</span>
                                    <span class="bg-indigo-600 hover:bg-indigo-700 dark:bg-indigo-500 dark:hover:bg-indigo-600 text-white font-semibold py-2.5 px-5 rounded-md text-lg z-10">Select a PDF</span>
                                    <p class="flex items-center text-sm text-slate-500 dark:text-slate-400 pt-2">
                                        <svg class="h-5 w-5 mr-1.5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 1a4.5 4.5 0 00-4.5 4.5V9H5a2 2 0 00-2 2v6a2 2 0 002 2h10a2 2 0 002-2v-6a2 2 0 00-2-2h-.5V5.5A4.5 4.5 0 0010 1zm3 8V5.5a3 3 0 10-6 0V9h6z" clip-rule="evenodd" /></svg>
                                        Files are processed locally & never leave your device.
                                    </p>
                                </div>
                            </label>
                            <input type="file" id="file-input" accept=".pdf" class="hidden">
                        </div>
                         <div id="file-info-container" class="mt-4 flex justify-center items-center gap-4 flex-wrap">
                            <p id="file-info" class="font-semibold text-indigo-600 dark:text-indigo-400 text-center"></p>
                            <button id="reset-btn" class="hidden w-full sm:w-auto text-white bg-indigo-600 hover:bg-indigo-700 font-semibold rounded-lg text-base px-5 py-3 transition-colors dark:bg-indigo-500 dark:hover:bg-indigo-600">Start Over</button>
                         </div>
                    </section>

                    <!-- Step 2: Controls -->
                    <section id="controls" class="hidden mt-8 max-w-3xl mx-auto">
                        <h2 class="text-2xl font-bold text-slate-800 dark:text-slate-100 border-b border-slate-300 dark:border-slate-600 pb-3">2. Choose an Operation</h2>
                        <div class="mt-6 space-y-6">
                          <fieldset id="panel-delete">
                              <label for="delete-pages" class="block text-lg font-bold text-slate-700 dark:text-slate-300">Pages to Delete</label>
                              <input type="text" id="delete-pages" placeholder="e.g., 3, 8-10, 15" class="mt-2 block w-full px-4 py-2 bg-white dark:bg-slate-700 border border-slate-300 dark:border-slate-600 rounded-md text-base placeholder-slate-400 focus:outline-none focus:border-indigo-500 focus:ring-1 focus:ring-indigo-500">
                              <p class="text-sm text-slate-500 dark:text-slate-400 mt-2">Deletes the specified pages, then saves each of the remaining pages as a separate file.</p>
                          </fieldset>
                        </div>
                        <div class="mt-8 flex flex-col sm:flex-row gap-4">
                            <button id="process-btn" class="flex-1 text-white bg-indigo-600 hover:bg-indigo-700 font-semibold rounded-lg text-lg px-5 py-3 transition-all dark:bg-indigo-500 dark:hover:bg-indigo-600">Delete & Save Pages</button>
                            <button id="extract-all-btn" class="flex-1 bg-slate-200 hover:bg-slate-300 text-slate-800 font-semibold rounded-lg text-lg px-5 py-3 transition-colors dark:bg-slate-600 dark:hover:bg-slate-500 dark:text-slate-200">Extract Every Page</button>
                        </div>
                    </section>

                    <!-- Status & Results -->
                    <div id="status-area" class="text-center mt-6 hidden">
                        <div id="loader" class="loader w-10 h-10 border-4 rounded-full mx-auto my-4 hidden"></div>
                        <p id="progress-message" class="font-medium text-lg text-slate-600 dark:text-slate-300"></p>
                        <div id="error-message" class="hidden mt-4 font-medium text-white bg-red-500/90 rounded-lg p-4"></div>
                    </div>

                    <section id="results-container" class="hidden mt-8">
                        <h2 class="text-2xl font-bold text-slate-800 dark:text-slate-100 border-b border-slate-300 dark:border-slate-600 pb-3">3. Your Files</h2>
                         <div class="mt-6 flex flex-col sm:flex-row gap-4">
                            <button id="download-combined-btn" class="flex-1 hidden text-white bg-indigo-600 hover:bg-indigo-700 font-semibold rounded-lg text-lg px-5 py-3 transition-all dark:bg-indigo-500 dark:hover:bg-indigo-600">Download All Combined</button>
                             <button id="download-separately-btn" class="flex-1 hidden text-white bg-indigo-600 hover:bg-indigo-700 font-semibold rounded-lg text-lg px-5 py-3 transition-all dark:bg-indigo-500 dark:hover:bg-indigo-600">Download as ZIP</button>
                        </div>
                        <div id="results-list" class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4 sm:gap-6 mt-8"></div>
                    </section>
                </section>

                <div class="my-4">
                    <div id="midad-1" aria-label="Mid Ad 1"></div>
                </div>
            </div>

            <aside class="hidden lg:flex flex-col space-y-4">
              <div id="sidead-1" aria-label="Sidebar Ad 1"></div>
              <div id="sidead-2" aria-label="Sidebar Ad 2"></div>
            </aside>
        </div>

        <div class="mb-4">
          <div id="topad-2" aria-label="Top Ad 2"></div>
        </div>
    </div>
</main>

<div id="footer-placeholder"></div>

<script defer>
document.addEventListener('DOMContentLoaded', () => {
    // Check if all required libraries are loaded
    if (typeof PDFLib === 'undefined' || typeof pdfjsLib === 'undefined' || typeof JSZip === 'undefined') {
        alert("Error: A required library (PDF-LIB, PDF.js, or JSZip) could not be loaded. Please check your internet connection and try refreshing the page.");
        return;
    }

    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.worker.min.js';

    const { PDFDocument, degrees } = PDFLib;
    const getEl = (id) => document.getElementById(id);

    const uploadArea = getEl('upload-area');
    const fileInput = getEl('file-input');
    const fileInfo = getEl('file-info');
    const controls = getEl('controls');
    const processBtn = getEl('process-btn');
    const extractAllBtn = getEl('extract-all-btn');
    const resetBtn = getEl('reset-btn');
    const downloadCombinedBtn = getEl('download-combined-btn');
    const downloadSeparatelyBtn = getEl('download-separately-btn');
    const statusArea = getEl('status-area');
    const loader = getEl('loader');
    const progressMessage = getEl('progress-message');
    const errorMessage = getEl('error-message');
    const resultsContainer = getEl('results-container');
    const resultsList = getEl('results-list');
    const uploadSection = getEl('upload-section');

    let pdfBytes = null, pageCount = 0, originalFilename = '';

    function resetAll() {
        pdfBytes = null; pageCount = 0; originalFilename = '';
        fileInput.value = ''; fileInfo.textContent = '';
        resultsList.innerHTML = ''; getEl('delete-pages').value = '';

        controls.classList.add('hidden');
        resetBtn.classList.add('hidden');
        resultsContainer.classList.add('hidden');
        statusArea.classList.add('hidden');
        errorMessage.classList.add('hidden');
        uploadSection.classList.remove('hidden');
        uploadArea.classList.remove('hidden');

        [processBtn, extractAllBtn, resetBtn, downloadCombinedBtn, downloadSeparatelyBtn].forEach(b => {
            b.disabled = false;
        });
    }
    resetAll();

    fileInput.addEventListener('change', () => { if (fileInput.files.length) handleFile(fileInput.files[0]); });

    const uploadLabel = uploadArea.querySelector('label');
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eName => {
        uploadArea.addEventListener(eName, e => {
            e.preventDefault();
            e.stopPropagation();
            if (eName === 'dragenter' || eName === 'dragover') {
                uploadLabel.classList.add('border-indigo-600', 'dark:border-indigo-300');
                uploadLabel.classList.remove('border-slate-400', 'dark:border-slate-500');
            } else {
                uploadLabel.classList.remove('border-indigo-600', 'dark:border-indigo-300');
                uploadLabel.classList.add('border-slate-400', 'dark:border-slate-500');
            }
            if (eName === 'drop' && e.dataTransfer.files.length) {
                fileInput.files = e.dataTransfer.files;
                handleFile(e.dataTransfer.files[0]);
            }
        });
    });

    processBtn.addEventListener('click', () => processRequest(handleDeletePages));
    extractAllBtn.addEventListener('click', () => processRequest(handleExtractAllPages));
    resetBtn.addEventListener('click', resetAll);
    downloadCombinedBtn.addEventListener('click', handleDownloadCombined);
    downloadSeparatelyBtn.addEventListener('click', handleDownloadSeparately);

    async function handleFile(file) {
        if (!file || file.type !== 'application/pdf') {
            showStatus("Please upload a valid PDF file.", 'error');
            return;
        }

        resultsList.innerHTML = '';
        errorMessage.classList.add('hidden');
        controls.classList.add('hidden');
        resultsContainer.classList.add('hidden');

        showStatus("Loading PDF...");
        originalFilename = file.name.replace(/\.pdf$/i, '');
        try {
            pdfBytes = new Uint8Array(await file.arrayBuffer());
            const pdfDoc = await PDFDocument.load(pdfBytes, { ignoreEncryption: true });
            pageCount = pdfDoc.getPageCount();

            statusArea.classList.add('hidden');
            fileInfo.textContent = `✓ ${file.name} (${pageCount} pages)`;
            controls.classList.remove('hidden');
            resetBtn.classList.remove('hidden');
            uploadArea.classList.add('hidden');
        } catch (e) {
            console.error("File handling error:", e);
            resetAll();
            showStatus(`Could not read the PDF. It may be corrupt or encrypted.`, 'error');
        }
    }

    function showStatus(message, type = 'loading') {
        statusArea.classList.remove('hidden');
        errorMessage.classList.add('hidden');
        progressMessage.classList.add('hidden');
        loader.classList.add('hidden');

        if (type === 'error') {
            errorMessage.classList.remove('hidden'); errorMessage.innerHTML = message;
        } else {
            progressMessage.classList.remove('hidden'); progressMessage.innerHTML = message;
            loader.classList.remove('hidden');
        }
    }

    async function processRequest(handler) {
        resultsList.innerHTML = '';
        resultsContainer.classList.add('hidden');
        [processBtn, extractAllBtn, resetBtn].forEach(btn => btn.disabled = true);
        try {
            await handler();
        } catch (e) {
            console.error("Processing error:", e);
            showStatus(e.message, 'error');
        } finally {
            [processBtn, extractAllBtn, resetBtn].forEach(btn => btn.disabled = false);
            finalizeResults();
        }
    }

    function finalizeResults() {
        const numCards = resultsList.children.length;
        if (errorMessage.classList.contains('hidden')) statusArea.classList.add('hidden');

        if (numCards > 0) {
            resultsContainer.classList.remove('hidden');
            downloadCombinedBtn.classList.toggle('hidden', numCards <= 1);
            downloadSeparatelyBtn.textContent = 'Download as ZIP';
            downloadSeparatelyBtn.classList.toggle('hidden', numCards <= 1);
        } else {
            resultsContainer.classList.add('hidden');
            if (errorMessage.classList.contains('hidden')) {
               showStatus("No files were generated. Please check your page input.", 'error');
            }
        }
    }

    async function handleDeletePages() {
        const pagesToDeleteStr = getEl('delete-pages').value;
        const pagesToDelete = parsePageList(pagesToDeleteStr, pageCount);

        if (!pagesToDelete || pagesToDelete.size === 0) throw new Error("Please enter valid page numbers to delete.");

        const pagesToKeep = Array.from({ length: pageCount }, (_, i) => i + 1).filter(p => !pagesToDelete.has(p));

        if (pagesToKeep.length === pageCount) throw new Error("None of the pages you entered were found in the PDF.");
        if (pagesToKeep.length === 0) throw new Error("This operation would result in an empty PDF. Please keep at least one page.");

        showStatus(`Preparing ${pagesToKeep.length} remaining pages...`);
        const sourceDoc = await PDFDocument.load(pdfBytes, { ignoreEncryption: true });

        for (const [index, pageNum] of pagesToKeep.entries()) {
            progressMessage.textContent = `Creating file for page ${pageNum}... (${index + 1} of ${pagesToKeep.length})`;
            const resultBytes = await createPdfFromPages(sourceDoc, [pageNum]);
            await addDownloadCard(resultBytes, `${originalFilename}_page_${pageNum}.pdf`, `Page ${pageNum}`);
        }
    }

    async function handleExtractAllPages() {
        showStatus(`Extracting all ${pageCount} pages...`);
        const sourceDoc = await PDFDocument.load(pdfBytes, { ignoreEncryption: true });
        for (let i = 1; i <= pageCount; i++) {
            progressMessage.textContent = `Creating file for page ${i} of ${pageCount}...`;
            const resultBytes = await createPdfFromPages(sourceDoc, [i]);
            await addDownloadCard(resultBytes, `${originalFilename}_page_${i}.pdf`, `Page ${i}`);
        }
    }

    async function handleDownloadCombined() {
        const cards = Array.from(resultsList.children);
        if (cards.length <= 1) return;

        [downloadCombinedBtn, downloadSeparatelyBtn, resetBtn].forEach(b => b.disabled = true);
        showStatus("Merging files into a single PDF...");
        try {
            const blobs = await Promise.all(cards.map(card => fetch(card.dataset.url).then(res => res.blob())));
            const mergedDoc = await PDFDocument.create();
            for (const blob of blobs) {
                const pdfToMerge = await PDFDocument.load(await blob.arrayBuffer());
                const copiedPages = await mergedDoc.copyPages(pdfToMerge, pdfToMerge.getPageIndices());
                copiedPages.forEach(page => mergedDoc.addPage(page));
            }
            const mergedBytes = await mergedDoc.save();
            downloadBlob(new Blob([mergedBytes], { type: 'application/pdf' }), `${originalFilename}_combined.pdf`);
            statusArea.classList.add('hidden');
        } catch (e) {
            showStatus(`Error merging files: ${e.message}`, 'error');
        } finally {
            [downloadCombinedBtn, downloadSeparatelyBtn, resetBtn].forEach(b => b.disabled = false);
        }
    }
    
    async function handleDownloadSeparately() {
        const cards = Array.from(resultsList.children);
        if (cards.length <= 1) return;

        [downloadCombinedBtn, downloadSeparatelyBtn, resetBtn].forEach(b => b.disabled = true);
        showStatus(`Creating ZIP file with ${cards.length} PDFs...`);
        try {
            const zip = new JSZip();
            await Promise.all(cards.map(async (card, index) => {
                progressMessage.textContent = `Adding file ${index + 1} of ${cards.length} to ZIP...`;
                const blob = await fetch(card.dataset.url).then(res => res.blob());
                zip.file(card.dataset.filename, blob);
            }));

            progressMessage.textContent = 'Generating ZIP file...';
            const zipBlob = await zip.generateAsync({ type: "blob" });
            downloadBlob(zipBlob, `${originalFilename}_pages.zip`);
            statusArea.classList.add('hidden');
        } catch (e) {
             showStatus(`Error creating ZIP file: ${e.message}`, 'error');
        } finally {
             [downloadCombinedBtn, downloadSeparatelyBtn, resetBtn].forEach(b => b.disabled = false);
        }
    }

    async function handleRotate(event) {
        const card = event.currentTarget.closest('.result-card');
        if (!card) return;

        card.querySelectorAll('button').forEach(b => b.disabled = true);
        try {
            const oldUrl = card.dataset.url;
            const pdfBytes = new Uint8Array(await (await fetch(oldUrl)).arrayBuffer());
            const pdfDoc = await PDFDocument.load(pdfBytes);

            const page = pdfDoc.getPage(0);
            const currentRotation = page.getRotation().angle;
            page.setRotation(degrees((currentRotation + 90) % 360));

            const newPdfBytes = await pdfDoc.save();
            const blob = new Blob([newPdfBytes], { type: 'application/pdf' });
            const newUrl = URL.createObjectURL(blob);

            card.dataset.url = newUrl;
            card.querySelector('.download-card-btn').onclick = () => downloadBlob(blob, card.dataset.filename);
            
            URL.revokeObjectURL(oldUrl); // Clean up old URL
            await renderPdfPreview(card.querySelector('canvas'), newPdfBytes);
        } catch (e) {
            console.error("Rotation error:", e);
            alert("An error occurred while rotating the PDF.");
        } finally {
            card.querySelectorAll('button').forEach(b => b.disabled = false);
        }
    }

    function downloadBlob(blob, filename) {
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        setTimeout(() => URL.revokeObjectURL(link.href), 100);
    }

    async function createPdfFromPages(sourceDoc, pageNumbers) {
        const newPdfDoc = await PDFDocument.create();
        const indices = pageNumbers.map(n => n - 1);
        const copiedPages = await newPdfDoc.copyPages(sourceDoc, indices);
        copiedPages.forEach(page => newPdfDoc.addPage(page));
        return newPdfDoc.save();
    }

    async function addDownloadCard(bytes, filename, displayName) {
        const card = document.createElement('div');
        card.className = 'result-card relative group bg-white dark:bg-slate-800 border border-slate-300 dark:border-slate-700 rounded-lg overflow-hidden flex flex-col shadow-sm';

        const blob = new Blob([bytes], { type: 'application/pdf' });
        const url = URL.createObjectURL(blob);
        card.dataset.url = url;
        card.dataset.filename = filename;

        card.innerHTML = `
            <div class="absolute z-10 flex flex-col gap-2 opacity-0 group-hover:opacity-100 transition-opacity">
                <button class="download-card-btn bg-transparent text-2xl" title="Download">⬇️</button>
                <button class="rotate-card-btn bg-transparent text-2xl" title="Rotate 90°">🔄</button>
                <button class="delete-card-btn bg-transparent text-xl" title="Remove">❌</button>
            </div>
            <div class="w-full h-48 flex items-center justify-center p-2 bg-slate-100 dark:bg-slate-700"><canvas class="max-w-full max-h-full"></canvas></div>
            <span class="block font-semibold text-center p-2 border-t border-indigo-300 truncate" title="${displayName}">${displayName}</span>
        `;

        card.querySelector('.download-card-btn').addEventListener('click', () => downloadBlob(blob, filename));
        card.querySelector('.delete-card-btn').addEventListener('click', () => { card.remove(); URL.revokeObjectURL(url); finalizeResults(); });
        card.querySelector('.rotate-card-btn').addEventListener('click', handleRotate);

        resultsList.appendChild(card);
        await renderPdfPreview(card.querySelector('canvas'), bytes);
    }

    async function renderPdfPreview(canvas, bytes) {
        try {
            const pdf = await pdfjsLib.getDocument({data: new Uint8Array(bytes)}).promise;
            const page = await pdf.getPage(1);
            const viewport = page.getViewport({ scale: 1.5 });
            canvas.height = viewport.height;
            canvas.width = viewport.width;
            await page.render({ canvasContext: canvas.getContext('2d'), viewport }).promise;
        } catch (err) {
            console.error("Preview render error:", err);
            canvas.parentElement.innerHTML = `<span class="text-xs text-slate-500">Preview failed</span>`;
        }
    }

    function parsePageList(str, max) {
        if (!str?.trim()) return null;
        const pages = new Set();
        try {
            str.replace(/\s/g, '').split(',').forEach(part => {
                if (!part) return;
                if (part.includes('-')) {
                    let [start, end] = part.split('-').map(Number);
                    if (isNaN(start) || isNaN(end) || start < 1 || start > end || end > max) throw new Error(`Range '${part}' is invalid.`);
                    for (let i = start; i <= end; i++) pages.add(i);
                } else {
                    const num = Number(part);
                    if (isNaN(num) || num < 1 || num > max) throw new Error(`Page '${part}' is invalid.`);
                    pages.add(num);
                }
            });
        } catch (e) {
            throw new Error(`Invalid page format. ${e.message}`);
        }
        return pages.size > 0 ? pages : null;
    }
});
</script>

</body>
</html>
